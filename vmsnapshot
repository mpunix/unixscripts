#!/bin/bash

#

#

# Diego Diez Beinat 09-2016: Modified and added new functionalities for taking and rolling back snapshots in VMs. Includes new options to rollback from PBE or ABE. Also provides new mechanism for taking snapshots when there is no 

# space available in rootvg to take a full volume size snapshot. Used in Rundeck for patching automation. The snapshots created will be automatically checked every 30 mins and automatically removed after 3 days

# Diego Diez Beinat 04-2017: Added new functions to support RHEL 7 snapshots

# Verified for RHEL 6

# Verified for RHEL 7



### LOCALVG can be removed from the snapshots. It has been already removed from the rollback options

 

set -o nounset # error on undefined variables

set +o errexit # +=don't exit on error

 

GLOBALRET=0

ROOTVG="rootvg"

SNAPLVSRC="rootlv varlv optlv exportlv" 

LOCALVG="localvg"

LOCALLVSRC="optapplv sysadminlv"

SNAP_LOGFILE=/var/log/snap.log.`date "+%FT%X"`

 

SNAPLV=""

for lv in $SNAPLVSRC

do

  [ -b /dev/$ROOTVG/$lv ] && SNAPLV="$SNAPLV $lv"

done

 

LOCALLV=""

if [ -d /dev/$LOCALVG ]; then

 for lv in $LOCALLVSRC

  do

    [ -b /dev/$LOCALVG/$lv ] && LOCALLV="$LOCALLV $lv"

  done

fi

 

PLACEHOLDER="abe_placeholder"

 

function debug() {

  echo $1 | tee -a $SNAP_LOGFILE

}

 

function usage {

  echo "Usage: `basename $0` <check|checkfull|snap|PBEsnap|PBErollback|remove|rollback>"

  echo " - check: looks for signs of existing ABE solutions"

  echo " - checkfull: verify if the snap volumes are full or inactive"

  echo " - snap: remove any existing ABE and create a new one, using lvm snapshots. The new snapshot will be added to GRUB"

  echo "         please note that the filesystem can be inconsistent when writes happen during snapshot"

  echo " - PBEsnap: remove any existing ABE and create a new one, using lvm snapshots. The new snapshot will NOT be added to GRUB"

  echo "         please note that the filesystem can be inconsistent when writes happen during snapshot"

  echo " - PBErollback: revert to last snapshot. MUST be run when the system is booted from the PBE, requires a reboot afterwards. Can be used to rollback snapshots that were taken using both snap options available in this script (PBEsnap and snap)"

  echo "         please note that on RHEL6 and RHEL7, rollback also removes the snapshots so they may have to be made again"

  echo " - remove: remove the existing ABE and create a dummy LV to reserve the space"

  echo " - rollback: revert to last snapshot. MUST be run when the system is booted from the snapshot ABE, requires a reboot afterwards. MUST be used ONLY if snap option was previously used"

  echo "         please note that on RHEL6 and RHEL7, rollback also removes the snapshots so they may have to be made again"

  exit 1

}

 

function checkabe() {

  debug "[INFO] Running checkabe"

  ABE=0

  /sbin/lvs $ROOTVG | grep -q ABE && ABE=$(( ABE + 1 ))

  for D in abe-export abe-opt abe-root abe-tmp abe-var

  do

    if [ -d /$D ]

    then

      #   echo "/$D exists"

      ABE=$(( ABE + 1 ))

    fi

  done

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then # this must be rhel6

        grep -q "root=/dev/mapper/$ROOTVG-ABErootlv\|root=/dev/$ROOTVG/ABErootlv " /boot/grub/grub.conf && ABE=$(( ABE + 1 ))

  else

        uname -r |grep -q ^3.10.0

        if [ $? -eq 0 ]

        then # this must be rhel7

                grep -q "root=/dev/mapper/$ROOTVG-ABErootlv\|root=/dev/$ROOTVG/ABErootlv " /boot/grub2/grub.cfg && ABE=$(( ABE + 1 ))

        fi

  fi

  debug "[INFO] checkabe found $ABE items"

  return $ABE

}

 

function checksnap() {

  debug "[INFO] Running checksnap"

  SNAP=0

  for lv in $SNAPLV

  do

    [ -d /snap/${lv} ] && SNAP=$(( SNAP + 1 ))

    /sbin/lvs $ROOTVG |grep -q ${lv}_snap && SNAP=$(( SNAP + 1 ))

  done

 

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then # this must be rhel6

        grep -q "root=/dev/mapper/$ROOTVG-rootlv_snap\|root=/dev/mapper/$ROOTVG/ABErootlv_snap" /boot/grub/grub.conf && SNAP=$(( SNAP + 1 ))

  else

        uname -r |grep -q ^3.10.0

        if [ $? -eq 0 ]

        then # this must be rhel7

                grep -q "root=/dev/mapper/$ROOTVG-rootlv_snap\|root=/dev/mapper/$ROOTVG/ABErootlv_snap" /boot/grub2/grub.cfg && SNAP=$(( SNAP + 1 ))

        fi

  fi

 

  debug "[INFO] checksnap found $SNAP items"

  return $SNAP

}

 

function checkspace() {

  debug "[INFO] Running checkspace"

  # VGFREE is actual free space plus space which would be freed (placeholder + current snapshots)

  VGFREE=`/sbin/vgdisplay -c $ROOTVG |cut -d":" -f 16`

  if [ -d /dev/$LOCALVG ] ; then

    VGFREEL=`/sbin/vgdisplay -c $LOCALVG |cut -d":" -f 16`

  else

    VGFREEL="0"

  fi

  PLACEHOLDER_SIZE=0

  PLACEHOLDER_SIZEL=0

  [ -b /dev/$ROOTVG/$PLACEHOLDER ] && PLACEHOLDER_SIZE=`/sbin/lvdisplay -c /dev/$ROOTVG/$PLACEHOLDER |cut -d":" -f 8`

  for lv in $SNAPLV

  do

    LE=0

    [ -b /dev/$ROOTVG/${lv}_snap ] && LE=`/sbin/lvdisplay -c /dev/$ROOTVG/${lv}_snap |cut -d":" -f 8`

    PLACEHOLDER_SIZE=$(( PLACEHOLDER_SIZE + LE ))

    LE=0

    [ -b /dev/$ROOTVG/ABE${lv} ] && LE=`/sbin/lvdisplay -c /dev/$ROOTVG/ABE${lv} |cut -d":" -f 8`

    PLACEHOLDER_SIZE=$(( PLACEHOLDER_SIZE + LE ))

  done

  VGFREE=$(( VGFREE + PLACEHOLDER_SIZE ))

  ##debug "VGFREE=$VGFREE"

  WANTED=0

  for lv in $SNAPLV

  do

    LE=`/sbin/lvdisplay -c /dev/$ROOTVG/$lv |cut -d":" -f 8`

    WANTED=$(( WANTED + LE ))

  done

  if [ $VGFREE -lt $WANTED ]

  then

    debug "[WARNING] Not enough free space to create a full volume size snapshot of the $ROOTVG. Needed extents=$WANTED but only $VGFREE available in $ROOTVG."

    exit 1

  fi

 

  /sbin/vgs $LOCALVG > /dev/null 2>&1

  if [ $? -eq 0 ]

  then

        for lv in $LOCALLV

        do

                LE=0

                [ -b /dev/$LOCALVG/${lv}_snap ] && LE=`/sbin/lvdisplay -c /dev/$LOCALVG/${lv}_snap |cut -d":" -f 8`

                PLACEHOLDER_SIZEL=$(( PLACEHOLDER_SIZEL + LE ))

                LE=0

                [ -b /dev/$LOCALVG/ABE${lv} ] && LE=`/sbin/lvdisplay -c /dev/$LOCALVG/ABE${lv} |cut -d":" -f 8`

                PLACEHOLDER_SIZEL=$(( PLACEHOLDER_SIZEL + LE ))

        done

        VGFREEL=$(( VGFREEL + PLACEHOLDER_SIZEL ))

        ##debug "VGFREEL=$VGFREEL"

        WANTEDL=0

        for lv in $LOCALLV

        do

                LE=`/sbin/lvdisplay -c /dev/$LOCALVG/$lv |cut -d":" -f 8`

                WANTEDL=$(( WANTED + LE ))

        done

        ##debug "WantedL=$WANTEDL"

        if [ $VGFREEL -lt $WANTEDL ]

        then

                debug "[WARNING] Not enough space. Needed extents=$WANTEDL but only $VGFREEL available in $LOCALVG."

                exit 1

        fi

  fi

}

 

function makesnap_checkspace() {

  # Checking rootvg available space

  debug "[INFO] Running makesnap_checkspace"

  # VGFREE is actual free space plus space which would be freed (placeholder + current snapshots)

  VGFREE=`/sbin/vgdisplay -c $ROOTVG |cut -d":" -f 16`

  PESIZE=`/sbin/vgdisplay -c $ROOTVG |cut -d":" -f 13`

  PLACEHOLDER_SIZE=0

  [ -b /dev/$ROOTVG/$PLACEHOLDER ] && PLACEHOLDER_SIZE=`/sbin/lvdisplay -c /dev/$ROOTVG/$PLACEHOLDER |cut -d":" -f 8`

  for lv in $SNAPLV

  do

    LE=0

    [ -b /dev/$ROOTVG/${lv}_snap ] && LE=`/sbin/lvdisplay -c /dev/$ROOTVG/${lv}_snap |cut -d":" -f 8`

    PLACEHOLDER_SIZE=$(( PLACEHOLDER_SIZE + LE ))

    LE=0

    [ -b /dev/$ROOTVG/ABE${lv} ] && LE=`/sbin/lvdisplay -c /dev/$ROOTVG/ABE${lv} |cut -d":" -f 8`

    PLACEHOLDER_SIZE=$(( PLACEHOLDER_SIZE + LE ))

  done

  VGFREE=$(( VGFREE + PLACEHOLDER_SIZE ))

  WANTED=0


  LE=0

  for lv in $SNAPLV

  do

    LE=`/sbin/lvdisplay -c /dev/$ROOTVG/$lv |cut -d":" -f 8`

    WANTED=$(( WANTED + LE ))

    LE=0

  done

  if [ $VGFREE -lt $WANTED ]

  then

    debug "[INFO] $WANTED extents needed but only $VGFREE available in $ROOTVG"

    debug "[INFO] No space available in the rootvg to create a full volume size snapshot. Analysing the system to create a reduced size snapshot"

    AV_SIZE=0

    AV_SIZE=$(( VGFREE * PESIZE )) # In KiB

    if [ $AV_SIZE -gt 5025792 ] # 4908 MiB

    then

        # Reduced size required

        debug "[WARNING] Creating a reduced size snapshot"

        return 2

    else

        if [ $AV_SIZE -gt 3861504 ] # 3771 MiB

        then

                # Super reduced size required

                debug "[WARNING] Less than 4.79GB available in the rootvg. Creating a super reduced size snapshot"

                return 3

        else

                # Less than 3772 MiB available. Check if a minimal size snapshot can be taken"

                if [ $AV_SIZE -gt 3024896 ] # 2954 MiB

                then

                        # Minimal size required

                        debug "[WARNING] Less than 3.68GB available in the rootvg. Creating a minimal size snapshot"

                        return 4

                else

                        debug "[WARNING] Less than 2.88GB available in the rootvg. Trying to create a minimal size snapshot with the available space"

                        return 4   # Will try to create extra reduced snapshot with the available space

                fi

        fi

    fi

  fi

  return 0

}

 

function place_cronjob(){

  debug "[INFO] Running place_cronjob"

  debug "[INFO] Creating auto-removal script"

  # If the script is not being run from /opt ensure there is a copy for auto-removal (valid for RHEL6 and RHEL 7)

  # RHEL 7 mounts /tmp as tmpfs so if the server is rebooted contents of /tmp will be removed

  # RHEL 6 and 7 can be configured with noexec mount option for /tmp so the script is placed in /opt to ensure auto removal

  if [ -x /opt/`basename $0` ]

  then

        debug "[PASS] Script for auto-removal already in place"

  else

        /bin/cp -p `dirname $0`/`basename $0` /opt/`basename $0`

        RC=$?

        if [ $RC -eq 0 ]

        then

                debug "[PASS] Script for auto-removal created"

        else

                debug "[WARNING] Script for auto-removal could not be created"

        fi

  fi

  debug "[INFO] Creating crontab file for snapshot auto-check and auto-removal"

  DAYOFWEEK=$(date +"%u")

  # Schedule the snapshot removal in 72 hours

  case $DAYOFWEEK in

  "4") DAYOFWEEK=0;;

  "5") DAYOFWEEK=1;;

  "6") DAYOFWEEK=2;;

  "7") DAYOFWEEK=3;;

  * ) DAYOFWEEK=$(( DAYOFWEEK + 3 ));;

  esac

  cat << EOF > /etc/cron.d/remove-snapshot

05,35 * * * * root /opt/`basename $0` checkfull;[ \$? != 0 ] && { /opt/`basename $0` removefullsnap;rm -f /opt/`basename $0`;rm -f /tmp/`basename $0`; }

00 21 * * `echo $DAYOFWEEK` root /opt/`basename $0` remove;rm -f /opt/`basename $0`;rm -f /tmp/`basename $0`

EOF

  if [ -f /etc/cron.d/remove-snapshot ]

  then

        debug "[PASS] crontab file created"

  else

        debug "[WARNING] crontab file has NOT be created. The snapshot will NOT be automatically removed after 72 hours"

  fi

  # RHEL 7 sometimes doesn't preserve new /etc/cron.d files across reboots unless the crond is restarted

  uname -r |grep -q ^3.10.0

  if [ $? -eq 0 ]

  then # this must be rhel7

        systemctl stop crond.service

        systemctl start crond.service

  fi

}

 

function rm_placeholder(){

  debug "[INFO] Running rm_placeholder"

  if [ -b /dev/$ROOTVG/$PLACEHOLDER ]

  then

    debug "[INFO] Removing placeholder in $ROOTVG"

    /sbin/lvremove -f /dev/$ROOTVG/$PLACEHOLDER > /dev/null

    if [ $? -eq 0 ]

    then

        debug "[PASS] placeholder removed in $ROOTVG"

    fi

  else

    debug "[INFO] No placeholder found in $ROOTVG"

  fi

  /sbin/vgs $LOCALVG > /dev/null 2>&1

  if [ $? -eq 0 ]

  then

        # LOCALVG exists

        if [ -b /dev/$LOCALVG/$PLACEHOLDER ]

        then

                debug "[INFO] Removing placeholder in $LOCALVG"

                /sbin/lvremove -f /dev/$LOCALVG/$PLACEHOLDER > /dev/null

                if [ $? -eq 0 ]

                then

                        debug "[PASS] placeholder removed in $LOCALVG"

                fi

        else

                debug "No placeholder found in $LOCALVG"

        fi

  fi

}

 

function checkfull(){

  # Critical threshold for snap usage

  SNAP_THRESHOLD=98

  # Modify logfile var

  SNAP_LOGFILE=/var/log/snap.checkfull.log

  /bin/date > $SNAP_LOGFILE

  CHECK_STATE=0

  for lv in $SNAPLV

  do

        debug "[INFO] Checking snap volume for $lv"

        if [ ! -b /dev/$ROOTVG/${lv}_snap ]

        then

                debug "[INFO] ${lv}_snap volume does not exist"

        else

                # Confirm if ${lv}_snap is full or inactive

                SNAP_USAGE=`/sbin/lvs 2>/dev/null | grep ${lv}_snap | awk '{print $6}'`

                FULL_USAGE=`echo $SNAP_USAGE | grep 100`

                if [ ${FULL_USAGE}x = "x" ]

                then

                        # ok, the volume is not full. Check if INACTIVE

                        SNAP_STATE=`/sbin/lvdisplay /dev/$ROOTVG/${lv}_snap 2>/dev/null | grep "snapshot status" | grep INACTIVE`

                        if [ ${SNAP_STATE}x = "x" ]

                        then

                                # ok not inactive. Check snap volume usage threshold

                                SNAP_USAGE=`echo $SNAP_USAGE | awk -F. '{print $1}'`

                                if [ $SNAP_USAGE -ge $SNAP_THRESHOLD ]

                                then

                                        debug "[WARNING] ${lv}_snap above ${SNAP_THRESHOLD}% threshold"

                                        CHECK_STATE=1

                                else

                                        debug "[INFO] ${lv}_snap OK"

                                fi

                        else

                                debug "[CRITICAL] ${lv}_snap is INACTIVE"

                                CHECK_STATE=1

                        fi

                else

                        debug "[CRITICAL] ${lv}_snap is FULL"

                        CHECK_STATE=1

                fi

        fi

  done

  exit $CHECK_STATE

}

 

function make_placeholder(){

  debug "[INFO] Running make_placeholder"

  if [ ! -b /dev/$ROOTVG/$PLACEHOLDER ]

  then

    WANTED=0

    for lv in $SNAPLV

    do

      LE=`/sbin/lvdisplay -c /dev/$ROOTVG/$lv |cut -d":" -f 8`

      WANTED=$(( WANTED + LE ))

    done

    debug "[INFO] LE required: $WANTED in $ROOTVG"

    if [ $WANTED -ne 0 ]

    then

        debug "[INFO] Creating placeholder for full size LVs snap in $ROOTVG"

        #/sbin/lvcreate -l $WANTED -n $PLACEHOLDER $ROOTVG > /dev/null 2>&1

        STD_ERR=$(/sbin/lvcreate -l $WANTED -n $PLACEHOLDER $ROOTVG 2>&1 > /dev/null)

        RC_PLACEHOLDER=$?

        if [ $RC_PLACEHOLDER -ne 0 ]

        then

                SPACE=`echo $STD_ERR | grep "insufficient free space" | wc -l`

                if [ $SPACE -ne 0 ]

                then

                        debug "[FAIL] placeholder creation failed in $ROOTVG. Insufficient free space in the vg"

                else

                        debug "[FAIL] placeholder creation failed in $ROOTVG"

                fi

        else

                debug "[PASS] placeholder created in $ROOTVG"

        fi

    fi

  else

    debug "[INFO] Placeholder already exists in $ROOTVG"

  fi

 

  /sbin/vgs $LOCALVG > /dev/null 2>&1

  if [ $? -eq 0 ]

  then

        # LOCALVG exist

   if [ ! -b /dev/$LOCALVG/$PLACEHOLDER ]

   then

    WANTED=0

    for lv in $LOCALLV

    do

      LE=`/sbin/lvdisplay -c /dev/$LOCALVG/$lv |cut -d":" -f 8`

      WANTED=$(( WANTED + LE ))

    done

    debug "[INFO] LE required: $WANTED in $LOCALVG"

        if [ $WANTED -ne 0 ]

        then

                debug "[INFO] Creating placeholder in $LOCALVG"

                /sbin/lvcreate -l $WANTED -n $PLACEHOLDER $LOCALVG > /dev/null 2>&1

                RET=$?

                if [ $RET -ne 0 ]

                then

                        debug "[FAIL] placeholder creation failed in $LOCALVG"

                else

                        debug "[PASS] placeholder created in $LOCALVG"

                fi

        fi

   else

    debug "[INFO] Placeholder already exists in $LOCALVG"

   fi

  fi

}

 

function checkstuff() {

  debug "[INFO] Running checkstuff"

  checkabe

  RET=$?

  [ $RET -ne 0 ] && debug "[INFO] Found $RET clues to Dump&Restore ABE on this system"

  checksnap

  RET=$?

  if [ $RET -ne 0 ]

  then

    debug "[INFO] Found $RET clues to Snapshot ABE on this system"

    echo -n "Timestamp of Snapshot ABE: "

    /sbin/lvdisplay /dev/rootvg/rootlv_snap  |grep "LV Creation host, time" |cut -d"," -f 3

  fi

  checkspace

}


 

function grub_boot_current_kernel() {

  debug "[INFO] Running grub_boot_current_kernel"

  KERNEL=`uname -r`

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then

        # RHEL 6

        TITLE=`grep ^title /boot/grub/grub.conf |grep -n -m 1 "\(Red Hat Enterprise\|RHEL6\|RHEL5\).*$KERNEL.$" |cut -d: -f 1`

        TITLE=$(( TITLE - 1 ))

 

        debug "[INFO] boot default should be: $TITLE"

 

        CURRENT=`grep ^default= /boot/grub/grub.conf |cut -f 2 -d=`

 

        debug "[INFO] Current default boot: $CURRENT"

 

        [ $TITLE -ne $CURRENT ] && sed -i "s/^default=.*$/default=$TITLE/" /boot/grub/grub.conf

  else

        uname -r |grep -q ^3.10.0

        if [ $? -eq 0 ]

        then

                # RHEL 7

                CURRENT_DEFAULT_INDEX=`grubby --default-index`

                debug "[INFO] Current default boot: $CURRENT_DEFAULT_INDEX"

                ##### We are not modifying the default one in RHEL 7

        fi

  fi

 

}

 

function rmabe() {

  # This function only applies to old RHEL 6 installations

  debug "[INFO] Running rmabe"

  for D in abe-export abe-opt abe-root abe-tmp abe-var

  do

   [ -d "/$D" ] && debug "Found directory /$D"

   [ -d "/$D" ] && rmdir /$D

  done

 

for lv in `/sbin/lvs $ROOTVG |grep ABE |awk '{print $1}'`

do

   debug "[INFO] removing ABE logical volume: $lv"

   /sbin/lvremove -f /dev/$ROOTVG/${lv} > /dev/null

done

 

uname -r |grep -q ^2.6.32

if [ $? -eq 0 ]

then

grep -i "^title.*abe\|^title.*snapshot" /boot/grub/grub.conf |sed 's/^title\ //' |while read T

do

echo "T=$T="

/sbin/grubby --remove-kernel=TITLE="$T"

done

fi

}

 

function rmsnap() {

  debug "[INFO] Running rmsnap"

  # ro root=/dev/rootvg/rootlv console=ttyS1,9600 crashkernel=128M@16M nousb

  cat /proc/cmdline |grep -q "root=/dev/mapper/$ROOTVG-rootlv \|root=/dev/rootvg/rootlv " # <- last space is kinda important. The entry will be valid for RHEL 6 and 7

  if [ $? -ne 0 ]

  then

    debug "[FAIL] Can't remove snapshot if the system is booted from it."

    exit 1

  fi

  for lv in $SNAPLV

  do

    mount |grep -q /snap/$lv && umount /snap/${lv}

    [ -d /snap/$lv ] && rmdir /snap/${lv}

    if [ -b /dev/$ROOTVG/${lv}_snap ]

    then

        debug "[INFO] Snap volume associated with $lv in $ROOTVG detected"

        /sbin/lvremove -f /dev/$ROOTVG/${lv}_snap > /dev/null

        if [ $? -eq 0 ]

        then

                debug "[PASS] Snap volume associated with $lv in $ROOTVG removed"

        else

                debug "[FAIL] Failed to remove ${lv}_snap in $ROOTVG"

        fi

    fi

  done

 

  # Remove /boot backup information that was collected before taking the snapshot

  [ -d /var/snapshot_boot_backup ] && rm -r /var/snapshot_boot_backup

 

  for lv in $LOCALLV

  do

    mount |grep -q /snap/$lv && umount /snap/${lv}

    [ -d /snap/$lv ] && rmdir /snap/${lv}

    if [ -b /dev/$LOCALVG/${lv}_snap ]

    then

        debug "[INFO] Snap volume associated with $lv in $LOCALVG detected"

        /sbin/lvremove -f /dev/$LOCALVG/${lv}_snap > /dev/null

        if [ $? -eq 0 ]

        then

                debug "[PASS] Snap volume associated with $lv in $LOCALVG removed"

        else

                debug "[FAIL] Failed to remove ${lv}_snap in $LOCALVG"

        fi

    fi

  done

 

  [ -d /snap ] && rmdir /snap

 

  # Remove auto-check and auto-remove crontab file

  [ -f /etc/cron.d/remove-snapshot ] && rm -f /etc/cron.d/remove-snapshot

 

uname -r |grep -q ^2.6.32

if [ $? -eq 0 ]

then # this must be rhel6

grep -i "^title.*abe\|^title.*snapshot" /boot/grub/grub.conf |sed 's/^title\ //' |while read T

do

echo "T=$T="

/sbin/grubby --remove-kernel=TITLE="$T"

done

fi

 

uname -r |grep -q ^3.10.0

if [ $? -eq 0 ]

then # this must be rhel7

  # Check index number currently used as default in order to restore it. The snapshot entry must be added as index 0

  CURRENT_DEFAULT_INDEX=`/sbin/grubby --default-index`

 

/sbin/grubby --info=ALL|grep -i "^title.*abe\|^title.*snapshot"|awk -F= '{print $2}'|while read T

do

echo "T=$T="

/sbin/grubby --remove-kernel=TITLE="$T"

done

 

  # Ensure grub points at the appropriate kernel once removed the snapshot information

  if [ $CURRENT_DEFAULT_INDEX -ge 1 ]

  then

        NEW_DEFAULT_INDEX=$(( CURRENT_DEFAULT_INDEX - 1 ))

        # Set the new default value

        /sbin/grubby --set-default-index=${NEW_DEFAULT_INDEX}

        if [ $? -ne 0 ]

        then

                debug "[FAIL] The default entry in grub2 has changed and could not be restored"

        else

                debug "[INFO] The default grub2 option has been set as before"

        fi

  else

        if [ $CURRENT_DEFAULT_INDEX -eq 0 ]

        then

                # The default entry was 0 so it must be set to 0 again (in this case removing the snapshot entry won't have impact on the default entry)

                /sbin/grubby --set-default-index=${CURRENT_DEFAULT_INDEX}

                if [ $? -ne 0 ]

                then

                        debug "[FAIL] The default entry in grub2 has changed and could not be restored"

                else

                        debug "[INFO] The default grub2 option has been set as before"

                fi

        fi

  fi

 

fi

 

}

 

function rmstuff {

  debug "[INFO] Running rmstuff"

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then # this must be rhel6

        prepare_grub # Must NOT be used for RHEL 7

        checkabe # ABE type vols can be found in RHEL 6 not in RHEL 7

        RET=$?

        if [ $RET -ne 0 ]

        then

                debug "[INFO] Previous ABE items found. Deleting previous ABE items"

                rmabe

        fi

  fi

  checksnap

  RET=$?

  if [ $RET -ne 0 ]

  then

        debug "[INFO] Previous snap items found. Deleting previous snap items"

        rmsnap

  fi

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then # this must be rhel6

        grub_boot_current_kernel # Must not be used for RHEL 7, the rmsnap function has set the default kernel as before for RHEL 7

        make_placeholder # Only used for RHEL 6

  fi

}

 

function rmfullsnap {

  debug "[INFO] Running rmfullsnap"

  checksnap

  RET=$?

  if [ $RET -ne 0 ]

  then

        debug "[INFO] Previous snap items found. Deleting previous snap items"

        rmsnap

  fi

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then # this must be rhel6

        make_placeholder

  fi

}

 

function PBEmakesnap {

  debug "[INFO] Running PBEmakesnap"

  # Check if RHEL 7

  uname -r |grep -q ^3.10.0

  if [ $? -eq 0 ]

  then # this must be rhel7, use the appropriate method for rhel7

        debug "[INFO] This option is ONLY available on RHEL 6, for RHEL 7 use snap option instead"

        exit 1

  fi

  # Verify available space to determine snaphot size to use

  RET_SPACE=0

  makesnap_checkspace

  RET_SPACE=$?

  rmstuff

  rm_placeholder

  cp /boot/grub/grub.conf /boot/grub/grub.conf.snapshot

  if [ $? -ne 0 ]

  then

        debug "[FAIL] The existing grub.conf file has not been backed up correctly"

  fi

 

  # Add a copy of /boot to a LVM volume

  debug "[INFO] Backing up /boot to /var/snapshot_boot_backup"

  mkdir -p /var/snapshot_boot_backup

 cp -r /boot /var/snapshot_boot_backup/

  if [ $? -ne 0 ]

  then

        debug "[FAIL] Backup up of /boot failed"

  fi

 

  SNAP_FAIL=0

 

  for lv in $SNAPLV

  do

        LE=`/sbin/lvdisplay -c /dev/$ROOTVG/$lv |cut -d":" -f 8`

        uname -r |grep -q ^2.6.32

        if [ $? -eq 0 ]

        then # this must be rhel6, we can use lvm snapshots.

                

                STD_ERR=0

                SPACE=0

                if [ $RET_SPACE -eq 0 ]

                then

                        debug "[INFO] Creating $lv snapshot"

                        STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -l $LE /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                        RC_LVCREATE=$?

                else

                        if [ $RET_SPACE -eq 2 ]

                        then

                                # Create a snapshot of the volume with a reduced size

                                case ${lv} in

                                rootlv) SIZE="1.5G";;

                                varlv)  SIZE="2G";;

                                optlv)  SIZE="1G";;

                                exportlv) SIZE="300M";;

                                *) SIZE="2G";;

                                esac

                                debug "[INFO] Taking snapshot of ${lv} with reduced size"

                                STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -L ${SIZE} /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                                RC_LVCREATE=$?

                        else

                                if [ $RET_SPACE -eq 3 ]

                                then

                                        # Create a snapshot of the volume with super reduced size

                                        case ${lv} in

                                        rootlv) SIZE="1.25G";;

                                        varlv)  SIZE="1.71G";;

                                        optlv)  SIZE="500M";;

                                        exportlv) SIZE="200M";;

                                        *) SIZE="2G";;

                                        esac

                                        debug "[INFO] Taking snapshot of ${lv} with super reduced size"

                                        STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -L ${SIZE} /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                                        RC_LVCREATE=$?

                                else

                                        # RET_SPACE=4 or other

                                        # Create a snapshot of the volume with minimal size

                                        case ${lv} in

                                        rootlv) SIZE="1G";;

                                        varlv)  SIZE="1.3G";;

                                        optlv)  SIZE="352M";;

                                        exportlv) SIZE="160M";;

                                        *) SIZE="2G";;

                                        esac

                                        debug "[INFO] Taking snapshot of ${lv} with a minimal size"

                                        STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -L ${SIZE} /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                                        RC_LVCREATE=$?

                                fi

                        fi

                fi

                if [ $RC_LVCREATE -ne 0 ]

                then

                        SPACE=`echo $STD_ERR | grep "insufficient free space" | wc -l`

                        if [ $SPACE -ne 0 ]

                        then

                                debug "[WARNING] Snapshot creation for ${lv} failed. Insufficient free space in the vg"

                        else

                                debug "[WARNING] Snapshot creation for ${lv} failed"

                        fi

                        SNAP_FAIL=1

                else

                        debug "[PASS] $lv snapshot created OK"

                fi

        fi

  done

 

  /sbin/vgs $LOCALVG > /dev/null 2>&1

  if [ $? -eq 0 ]

  then

        # LOCALVG exists

        for lv in $LOCALLV

        do

                debug "[INFO] Creating $lv snapshot in $LOCALLV"

                LE=`/sbin/lvdisplay -c /dev/$LOCALVG/$lv |cut -d":" -f 8`

                uname -r |grep -q ^2.6.32

                if [ $? -eq 0 ]

                then # this must be rhel6, we can use lvm snapshots.

                        /sbin/lvcreate -s -n ${lv}_snap -l $LE /dev/$LOCALVG/${lv} > /dev/null

                        if [ $? -ne 0 ]

                        then

                                debug "[WARNING] Snapshot creation for ${lv} failed"

                        else

                                debug "[PASS] $lv  snapshot created OK"

                        fi

                fi

        done

  fi

 

#### The following is no longer required because this is already done BEFORE running the snapshot in rmstuff function

####  grub_boot_current_kernel

 

  KVER=`uname -r` # 2.6.32-220.13.1.el6.x86_64

  INITRD=`ls /boot/initr*${KVER}.img`

###### No longer required because booting directly from the snapshot is NOT available with this function

######  /sbin/grubby --copy-default --add-kernel=/boot/vmlinuz-${KVER} --title="Snapshot `date "+%FT%X"`" --args=root=/dev/$ROOTVG/rootlv_snap --initrd=$INITRD

 

  if [ $SNAP_FAIL -eq 1 ]

  then

        debug "[WARNING] Snapshot of $ROOTVG vols did not complete correctly."

        GLOBALRET=1

  fi

 

  # Ensure snapshot is automatically removed after 72 hours

  place_cronjob

}

 

 

function makesnap_RHEL7 {

debug "[INFO] Running makesnap_RHEL7"

 

# It is critical to confirm if the dm-snapshot module is available in thenitramfs file of the server, otherwise in RHEL 7 the server will no longer be able to boot if there are snapshots of LVM volumes and the server is rebooted!!

 

KVER=`uname -r` # 3.10.0-327.el7.x86_64

INITRD_DM_SNAPSHOT=`lsinitrd /boot/initramfs-${KVER}.img | grep dm-snapshot | grep modules | wc -l`

if [ $INITRD_DM_SNAPSHOT -eq 1 ]

then

 

  # Check if dracut.conf has the dm-snapshot info

  cat /etc/dracut.conf | grep "add_drivers+=" | grep dm-snapshot

  if [ $? -ne 0 ]

  then

        debug "[CRITICAL] RHEL 7 snapshots MUST not be used if dracut.conf is not configured properly to add dm-snapshot driver"

        exit 1

  fi

 

  # Verify available space to determine snaphot size to use

  RET_SPACE=0

  makesnap_checkspace

  RET_SPACE=$?

 

  rmstuff

  rm_placeholder

 

  cp /boot/grub2/grub.cfg /boot/grub2/grub.cfg.snapshot

 

  SNAP_FAIL=0

  SNAP_COMPLETED=""

  SNAP_ROOTLV=0

 

  # Add a copy of /boot to a LVM volume

  debug "[INFO] Backing up /boot to /var/snapshot_boot_backup"

  mkdir -p /var/snapshot_boot_backup

  cp -r /boot /var/snapshot_boot_backup/

  if [ $? -ne 0 ]

  then

        debug "[FAIL] Backup up of /boot failed"

  fi

 

  for lv in $SNAPLV

  do

        LE=`/sbin/lvdisplay -c /dev/$ROOTVG/$lv |cut -d":" -f 8`

        uname -r |grep -q ^3.10.0

        if [ $? -eq 0 ]

        then # this must be rhel7, we can use lvm snapshots.

                ##/sbin/lvcreate -s -n ${lv}_snap -l $LE /dev/$ROOTVG/${lv} > /dev/null

                STD_ERR=0

                SPACE=0

                if [ $RET_SPACE -eq 0 ]

                then

                        debug "[INFO] Creating $lv snapshot"

                        STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -l $LE /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                        RC_LVCREATE=$?

                else

                        if [ $RET_SPACE -eq 2 ]

                       then

                                # Create a snapshot of the volume with a reduced size

                                case ${lv} in

                                rootlv) SIZE="1.5G";;

                                varlv)  SIZE="2G";;

                                optlv)  SIZE="1G";;

                                exportlv) SIZE="300M";;

                                *) SIZE="2G";;

                                esac

                                debug "[INFO] Taking snapshot of ${lv} with reduced size"

                                STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -L ${SIZE} /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                                RC_LVCREATE=$?

                        else

                                if [ $RET_SPACE -eq 3 ]

                                then

                                        # Create a snapshot of the volume with super reduced size

                                        case ${lv} in

                                        rootlv) SIZE="1.25G";;

                                        varlv)  SIZE="1.71G";;

                                        optlv)  SIZE="500M";;

                                        exportlv) SIZE="200M";;

                                        *) SIZE="2G";;

                                        esac

                                        debug "[INFO] Taking snapshot of ${lv} with super reduced size"

                                        STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -L ${SIZE} /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                                        RC_LVCREATE=$?

                                else

                                        # RET_SPACE=4 or other

                                        # Create a snapshot of the volume with a minimal size

                                        case ${lv} in

                                        rootlv) SIZE="1G";;

                                        varlv)  SIZE="1.3G";;

                                        optlv)  SIZE="352M";;

                                        exportlv) SIZE="160M";;

                                        *) SIZE="2G";;

                                        esac

                                        debug "[INFO] Taking snapshot of ${lv} with a minimal size"

                                        STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -L ${SIZE} /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                                        RC_LVCREATE=$?

                                fi

                        fi

                fi

                if [ $RC_LVCREATE -ne 0 ]

                then

                        SPACE=`echo $STD_ERR | grep "insufficient free space" | wc -l`

                        if [ $SPACE -ne 0 ]

                        then

                                debug "[WARNING] Snapshot creation for ${lv} failed. Insufficient free space in the vg"

                        else

                                debug "[WARNING] Snapshot creation for ${lv} failed"

                        fi

                        SNAP_FAIL=1

                else

                        debug "[PASS] $lv snapshot created OK"

                        SNAP_COMPLETED="$SNAP_COMPLETED $lv"

                        # Mount the snapshot volume. Later will update snapshot fstab file

                        debug "[INFO] Mounting snapshot volume ${lv}_snap"

                        mkdir -p /snap/${lv}

                        # xfs file system snapshots MUST be mounted with -o nouuid

                        XFS=`cat /etc/mtab | grep $ROOTVG | grep $lv | head -1 | awk '{print $3}'`

                        if [ "${XFS}x" = "xfsx" ]

                        then

                                mount -o nouuid /dev/$ROOTVG/${lv}_snap /snap/${lv}

                        else

                                mount /dev/$ROOTVG/${lv}_snap /snap/${lv} # This mount covers non xfs file systems AND xfs file systems whose original LVM volume is not currently mounted as well

                        fi

                        if [ $? -eq 0 ]

                        then

                                debug "[PASS] $ROOTVG snapshot volume ${lv}_snap mounted"

                        else

                                debug "[FAIL] Failed to mount volume ${lv}_snap"

                        fi

                        if [ "${lv}x" = "rootlvx" ]

                        then

                                SNAP_ROOTLV=1

                        fi

                fi

        fi

  done

 

  if [ $SNAP_FAIL -eq 1 ]

  then

        debug "[WARNING] Snapshot of $ROOTVG vols did not complete correctly."

        GLOBALRET=1

  fi

 

  # Update fstab in snapshot

 

  if [ $SNAP_ROOTLV -eq 0 ]

  then

        debug "[WARNING] Snapshot of rootlv failed. The snapshot is NOT valid"

        GLOBALRET=1

  else

        # Only update vfstab lines of vols with proper snapshot completed

        for lv in $SNAP_COMPLETED

        do

                debug "[INFO] Updating fstab in snapshot for $lv"

                # rhel7 syntax

                sed -i s/$ROOTVG-${lv}/$ROOTVG-${lv}_snap/ /snap/rootlv/etc/fstab

                #  VG/VOL syntax

                sed -i "s/$ROOTVG\/${lv}/$ROOTVG\/${lv}_snap/" /snap/rootlv/etc/fstab

        done

  fi

 

  # LOCALVG not used in RHEL7

 

  # Unmount snapshot volumes currently mounted.

  debug "[INFO] Unmounting snapshot volumes"

  for lv in $SNAP_COMPLETED

  do

        ## echo $lv

        mount |grep -q /snap/$lv && umount /snap/${lv}

        if [ $? -ne 0 ]

        then

                debug "[FAIL] Failed to unmount $lv"

        else

                debug "[PASS] $lv unmounted"

        fi

  done

 

  # Ensure grub points at the current kernel and add snapshot information

  # Check index number currently used as default in order to restore it because grubby can modify this information once added the snapshot. The snapshot entry will be added as index 0

  CURRENT_DEFAULT_INDEX=`/sbin/grubby --default-index`

  NEW_DEFAULT_INDEX=$(( CURRENT_DEFAULT_INDEX + 1 ))

 

  KVER=`uname -r` # 3.10.0-514.10.2.el7.x86_64

        #INITRD=`ls /boot/initr*${KVER}.img`

  /sbin/grubby --copy-default --add-kernel=/boot/vmlinuz-${KVER} --title="Snapshot `date "+%FT%X"`" --args=root=/dev/mapper/$ROOTVG-rootlv_snap --initrd=/boot/initramfs-${KVER}.img

        #/sbin/grubby --copy-default --add-kernel=/boot/vmlinuz-${KVER} --title="Snapshot `date "+%FT%X"`" --args=root=/dev/$ROOTVG/rootlv_snap --initrd=$INITRD

 

  # Restore the default value

  /sbin/grubby --set-default-index=${NEW_DEFAULT_INDEX}

  if [ $? -ne 0 ]

  then

        debug "[FAIL] The default entry in grub2 has changed and could not be restored"

  else

        debug "[INFO] The default grub2 option has been set as before"

  fi

 

  # Ensure snapshot is automatically removed after 48 hours

  place_cronjob

else

  debug "[CRITICAL] This server does not have dm-snapshot module included in initramfs file so LVM snapshots MUST NOT be used"

fi # Confirmation dm-snapshot available in initrd

}

 

function makesnap {

# Check if RHEL 7

uname -r |grep -q ^3.10.0

if [ $? -eq 0 ]

then # this must be rhel7, use the appropriate method for rhel7

        makesnap_RHEL7

else

  debug "[INFO] Running makesnap"

  # Verify available space to determine snaphot size to use

  RET_SPACE=0

  makesnap_checkspace

  RET_SPACE=$?

  rmstuff

  rm_placeholder

 

  cp /boot/grub/grub.conf /boot/grub/grub.conf.snapshot

 

  SNAP_FAIL=0

  SNAP_COMPLETED=""

  SNAP_ROOTLV=0

 

  # Add a copy of /boot to a LVM volume

  debug "[INFO] Backing up /boot to /var/snapshot_boot_backup"

  mkdir -p /var/snapshot_boot_backup

  cp -r /boot /var/snapshot_boot_backup/

  if [ $? -ne 0 ]

  then

        debug "[FAIL] Backup up of /boot failed"

  fi

 

  for lv in $SNAPLV

  do

        LE=`/sbin/lvdisplay -c /dev/$ROOTVG/$lv |cut -d":" -f 8`

        uname -r |grep -q ^2.6.32

        if [ $? -eq 0 ]

        then # this must be rhel6, we can use lvm snapshots.

                ##/sbin/lvcreate -s -n ${lv}_snap -l $LE /dev/$ROOTVG/${lv} > /dev/null

                STD_ERR=0

                SPACE=0

                if [ $RET_SPACE -eq 0 ]

                then

                        debug "[INFO] Creating $lv snapshot"

                        STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -l $LE /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                        RC_LVCREATE=$?

                else

                        if [ $RET_SPACE -eq 2 ]

                        then

                                # Create a snapshot of the volume with a reduced size

                                case ${lv} in

                                rootlv) SIZE="1.5G";;

                                varlv)  SIZE="2G";;

                                optlv)  SIZE="1G";;

                                exportlv) SIZE="300M";;

                                *) SIZE="2G";;

                                esac

                                debug "[INFO] Taking snapshot of ${lv} with reduced size"

                                STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -L ${SIZE} /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                                RC_LVCREATE=$?

                        else

                                if [ $RET_SPACE -eq 3 ]

                                then

                                        # Create a snapshot of the volume with super reduced size

                                        case ${lv} in

                                        rootlv) SIZE="1.25G";;

                                        varlv)  SIZE="1.71G";;

                                        optlv)  SIZE="500M";;

                                        exportlv) SIZE="200M";;

                                        *) SIZE="2G";;

                                        esac

                                        debug "[INFO] Taking snapshot of ${lv} with super reduced size"

                                        STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -L ${SIZE} /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                                        RC_LVCREATE=$?

                                else

                                        # RET_SPACE=4 or other

                                        # Create a snapshot of the volume with a minimal size

                                        case ${lv} in

                                        rootlv) SIZE="1G";;

                                        varlv)  SIZE="1.3G";;

                                        optlv)  SIZE="352M";;

                                        exportlv) SIZE="160M";;

                                        *) SIZE="2G";;

                                        esac

                                        debug "[INFO] Taking snapshot of ${lv} with a minimal size"

                                        STD_ERR=$(/sbin/lvcreate -s -n ${lv}_snap -L ${SIZE} /dev/$ROOTVG/${lv} 2>&1 > /dev/null)

                                       RC_LVCREATE=$?

                                fi

                        fi

                fi

                if [ $RC_LVCREATE -ne 0 ]

                then

                        SPACE=`echo $STD_ERR | grep "insufficient free space" | wc -l`

                        if [ $SPACE -ne 0 ]

                        then

                                debug "[WARNING] Snapshot creation for ${lv} failed. Insufficient free space in the vg"

                        else

                                debug "[WARNING] Snapshot creation for ${lv} failed"

                        fi

                        SNAP_FAIL=1

                else

                        debug "[PASS] $lv snapshot created OK"

                        SNAP_COMPLETED="$SNAP_COMPLETED $lv"

                        # Mount the snapshot volume. Later will update snapshot fstab file

                        debug "[INFO] Mounting snapshot volume ${lv}_snap"

                        mkdir -p /snap/${lv}

                        mount /dev/$ROOTVG/${lv}_snap /snap/${lv}

                        if [ $? -eq 0 ]

                        then

                                debug "[PASS] $ROOTVG snapshot volume ${lv}_snap mounted"

                        else

                                debug "[FAIL] Failed to mount volume ${lv}_snap"

                        fi

                        if [ "${lv}x" = "rootlvx" ]

                        then

                                SNAP_ROOTLV=1

                        fi

                fi

        fi

  done

 

  if [ $SNAP_FAIL -eq 1 ]

  then

        debug "[WARNING] Snapshot of $ROOTVG vols did not complete correctly."

        GLOBALRET=1

  fi

 

  # Update fstab in snapshot

 

  if [ $SNAP_ROOTLV -eq 0 ]

  then

        debug "[WARNING] Snapshot of rootlv failed. The snapshot is NOT valid"

        GLOBALRET=1

  else

        # Only update vfstab lines of vols with proper snapshot completed

        for lv in $SNAP_COMPLETED

        do

                debug "[INFO] Updating fstab in snapshot for $lv"

                # rhel6 syntax

                sed -i s/$ROOTVG-${lv}/$ROOTVG-${lv}_snap/ /snap/rootlv/etc/fstab

                # rhel5 syntax

                sed -i "s/$ROOTVG\/${lv}/$ROOTVG\/${lv}_snap/" /snap/rootlv/etc/fstab

        done

  fi

 

  # Now LOCALVG

 

  /sbin/vgs $LOCALVG > /dev/null 2>&1

  if [ $? -eq 0 ]

  then

        # LOCALVG exists

 

        SNAP_FAIL=0

        SNAP_LOCALVG_COMPLETED=""

 

        for lv in $LOCALLV

        do

                LE=`/sbin/lvdisplay -c /dev/$LOCALVG/$lv |cut -d":" -f 8`

                uname -r |grep -q ^2.6.32

                if [ $? -eq 0 ]

                then # this must be rhel6, we can use lvm snapshots.

                        debug "[INFO] Creating $lv snapshot"

                        /sbin/lvcreate -s -n ${lv}_snap -l $LE /dev/$LOCALVG/${lv} > /dev/null

                        if [ $? -ne 0 ]

                        then

                                debug "[WARNING] Snapshot creation for ${lv} failed"

                                SNAP_FAIL=1

                        else

                                debug "[PASS] $lv  snapshot created OK"

                                SNAP_LOCALVG_COMPLETED="$SNAP_LOCALVG_COMPLETED $lv"

                                # This is not the rootvg so there is no need to mount the snapshot

                        fi

                fi

        done

 

        if [ $SNAP_FAIL -eq 1 ]

        then

                debug "[WARNING] Snapshot of $LOCALVG vols did not complete correctly. Check before patching"

                GLOBALRET=1

        fi

 

        # Update LOCALVG vols in snapshot fstab file only if rootlv snapshot is good

        if [ $SNAP_ROOTLV -eq 0 ]

        then

                debug "[WARNING] Snapshot of rootlv failed."

                debug "[WARNING] LOCALVG vols has NOT been updated in snapshot fstab file"

                GLOBALRET=1

        else

                for lv in $SNAP_LOCALVG_COMPLETED

                do

                        debug "[INFO] Updating fstab in snapshot for $lv"

                        # rhel6 syntax

                        sed -i s/$LOCALVG-${lv}/$LOCALVG-${lv}_snap/ /snap/rootlv/etc/fstab

                        # rhel5 syntax

                        sed -i "s/$LOCALVG\/${lv}/$LOCALVG\/${lv}_snap/" /snap/rootlv/etc/fstab

                done

        fi

  fi

 

  # Unmount snapshot volumes currently mounted. LOCALVG snapshot vols are not mounted

  debug "[INFO] Unmounting snapshot volumes"

  for lv in $SNAP_COMPLETED

  do

        ## echo $lv

        mount |grep -q /snap/$lv && umount /snap/${lv}

        if [ $? -ne 0 ]

        then

                debug "[FAIL] Failed to unmount $lv"

        else

                debug "[PASS] $lv unmounted"

        fi

  done

 

  # Ensure grub points at the current kernel and add snapshot information

  grub_boot_current_kernel

 

  KVER=`uname -r` # 2.6.32-220.13.1.el6.x86_64

  INITRD=`ls /boot/initr*${KVER}.img`

  #/sbin/grubby --copy-default --add-kernel=/boot/vmlinuz-${KVER} --title="Snapshot `date "+%FT%X"`" --args=root=/dev/mapper/$ROOTVG-rootlv_snap --initrd=/boot/initramfs-${KVER}.img

  /sbin/grubby --copy-default --add-kernel=/boot/vmlinuz-${KVER} --title="Snapshot `date "+%FT%X"`" --args=root=/dev/$ROOTVG/rootlv_snap --initrd=$INITRD

 

# Ensure snapshot is automatically removed after 72 hours

place_cronjob

 

fi # rhel 7 check

}

 

function PBErollbacksnap {

### This fuction can rollback snaps that have been created using both options: snap and PBEsnap

### This function is designed to be run ONLY when the system is booted from the PBE

  debug "[INFO] Running rollbacksnap"

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then # this must be rhel6

        prepare_grub

  fi

 

# ro root=/dev/rootvg/rootlv console=ttyS1,9600 crashkernel=128M@16M nousb

  cat /proc/cmdline |grep -q "root=/dev/mapper/$ROOTVG-rootlv \|root=/dev/rootvg/rootlv "

  if [ $? -ne 0 ]

  then

        debug "[ERROR] This option can only be used to rollback when booted from the original volumes (PBE)"

        exit 1

  fi

 

### Critical checks before rolling back:

### Confirm if a snap volume exists for every critical rootvg volume

### Confirm that every snapshot volume is not full or inactive

  for lv in $SNAPLV

  do

        debug "[INFO] checking snap volume for $lv"

        if [ ! -b /dev/$ROOTVG/${lv}_snap ]

        then

                if [ "${lv}X" = "rootlvX" ]

                then

                        debug "[CRITICAL] rootlv_snap volume does NOT exist"

                else

                        debug "[ERROR] ${lv}_snap volume does NOT exist. Verify manually if the snapshot is reliable for rolling back"

                fi

                exit 1

        fi

 

        debug "[INFO] confirming if ${lv}_snap is full or inactive"

        SNAP_USAGE=`/sbin/lvs 2>/dev/null | grep ${lv}_snap | awk '{print $6}' | grep 100`

        if [ ${SNAP_USAGE}x = "x" ]

        then

                # ok, the volume is not full. Check if INACTIVE

                SNAP_STATE=`/sbin/lvdisplay /dev/$ROOTVG/${lv}_snap 2>/dev/null | grep "snapshot status" | grep INACTIVE`

                if [ ${SNAP_STATE}x = "x" ]

                then

                        # ok

                        debug "[INFO] ${lv}_snap OK"

                else

                        debug "[CRITICAL] ${lv}_snap is INACTIVE"

                        exit 1

                fi

        else

                debug "[CRITICAL] ${lv}_snap is FULL. Cannot rollback a full snapshot into its origin volume"

                exit 1

        fi

  done

 

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then

        # RHEL 6 only

        # Snapshot info could be included in grub.conf after the snapshot was taken, so it is required to restore the previous one that was copied when the snapshot was taken

        if [ -f /boot/grub/grub.conf.snapshot ]

        then

                cp /boot/grub/grub.conf.snapshot /boot/grub/grub.conf

                if [ $? -eq 0 ]

                then

                        debug "[INFO] RHEL 6 Previous /boot/grub/grub.conf has been restored"

                fi

        else

                debug "[FAIL] RHEL 6 /boot/grub/grub.conf.snapshot file was NOT found to restore the original grub configuration"

        fi

  else

        uname -r |grep -q ^3.10.0

        if [ $? -eq 0 ]

        then

                # RHEL 7 only

                # Snapshot info could be included in grub.cfg after the snapshot was taken, so it is required to restore the previous one that was copied when the snapshot was taken

                if [ -f /boot/grub2/grub.cfg.snapshot ]

                then

                        cp /boot/grub2/grub.cfg.snapshot /boot/grub2/grub.cfg

                        if [ $? -eq 0 ]

                        then

                                debug "[INFO] RHEL 7 Previous /boot/grub2/grub.cfg has been restored"

                        fi

                else

                        debug "[FAIL] RHEL 7 /boot/grub2/grub.cfg.snapshot file was NOT found to restore the original grub2 configuration"

                fi

        fi

  fi

 

  # Confirm fstab file in snapshot is configured as it should be

  mkdir -p /snap/rootlv

  XFS=`cat /etc/mtab | grep $ROOTVG | grep rootlv | head -1 | awk '{print $3}'`

  if [ "${XFS}x" = "xfsx" ]

  then

        mount -o nouuid /dev/$ROOTVG/rootlv_snap /snap/rootlv # xfs file system snapshots MUST be mounted with -o nouuid

  else

        mount /dev/$ROOTVG/rootlv_snap /snap/rootlv  # non xfs rootlv

  fi

  if [ $? -ne 0 ]

  then

        debug "[ERROR] rootlv_snap volume failed to mount. Please mount it and check fstab manually before rolling back"

        umount /snap/rootlv

        exit 1

  fi

 

  # Update fstab in snapshot fstab file because this file will overwrite the one contained in the original volume if it has been modified in the snapshot volume

  debug "[INFO] fixing fstab"

  sed -i s/_snap// /snap/rootlv/etc/fstab # RHEL 6 and RHEL 7

 

  umount /snap/rootlv

  if [ $? -ne 0 ]

  then

        debug "[FAIL] rootlv_snap volume failed to unmount"

  fi

 

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then # this must be rhel6, we can rollback lvm snapshots.

        for lv in $SNAPLV

        do

                debug "[INFO] rolling back to $lv"

                /sbin/lvconvert --merge /dev/rootvg/${lv}_snap

        done

 

        ######

        # The /boot contents will NOT be automatically recovered as part of the rollback function (/boot is a partition, not a LVM volume). In case of a /boot corruption the contents of it can be recovered to the previous status that was collected       #before creating the snapshot using the /var/snapshot_boot_backup backup. To do it manually the following can be done:

        # rm -rf /boot/*

        # cp -r /var/snapshot_boot_backup/boot/* /boot

        # rm -r /var/snapshot_boot_backup

        # if required install grub into the drive using grub-install /dev/xxxx

        ######

 

  else

        uname -r |grep -q ^3.10.0

        if [ $? -eq 0 ]

        then # this must be rhel7, we can rollback lvm snapshots.

                for lv in $SNAPLV

                do

                        debug "[INFO] rolling back to $lv"

                        /sbin/lvconvert --merge /dev/rootvg/${lv}_snap

                done

 

                ######

                # The /boot contents will NOT be automatically recovered as part of the rollback function (/boot is a partition, not a LVM volume). In case of a /boot corruption the contents of it can be recovered to the previous status that was #collected before creating the snapshot using the /var/snapshot_boot_backup backup. To do it manually the follwing can be done:

                # rm -rf /boot/*

                # cp -r /var/snapshot_boot_backup/boot/* /boot

                # rm -r /var/snapshot_boot_backup

                # if required install grub into the drive using grub-install /dev/xxxx

                ######

        else

                debug "[ERROR] Option only available for RHEL 6 and RHEL 7"

                exit 1

        fi

  fi

 

##### The server is not booted from ABE so the following is no longer required. If grub file has been modified after the snapshot was taken it will be overwritten

#####  grub_boot_current_kernel

 

###### CANNOT DETERMINE NEW DEFAULT KERNEL BECAUSE THE SYSTEM IS NOT BOOTED FROM THE SNAPSHOT. MUST RECOVER BASED IN PREVIOUS grub.conf COPY

 

# Not strictly necessary but will ensure in RHEL6 that the grub.conf copy restored do not contain snaps information

uname -r |grep -q ^2.6.32

if [ $? -eq 0 ]

then # this must be rhel6

  debug "[INFO] Checking grub.conf and deleting snapshot information from it"

grep -i "^title.*abe\|^title.*snapshot" /boot/grub/grub.conf |sed 's/^title\ //' |while read T

do

echo "T=$T="

/sbin/grubby --remove-kernel=TITLE="$T"

done

#####else

#### NOT USED FOR RHEL 7 because grubby changes the default index

####  uname -r |grep -q ^3.10.0

####  if [ $? -eq 0 ]

####  then # this must be rhel7

####    debug "[INFO] Checking grub2 and deleting snapshot information from it"

####/sbin/grubby --info=ALL|grep -i "^title.*abe\|^title.*snapshot"|awk -F= '{print $2}'|while read T

####do

#### echo "T=$T="

#### /sbin/grubby --remove-kernel=TITLE="$T"

####done

####  fi

fi

 

debug "[CRITICAL] Please REBOOT the server immediately to apply the rollback. If the rollback is being run from rundeck the server will be automatically rebooted now"

}

 

function rollbacksnap {

  debug "[INFO] Running rollbacksnap"

  uname -r |grep -q ^2.6.32

  if [ $? -eq 0 ]

  then # this must be rhel6

        prepare_grub

  fi

 

# ro root=/dev/rootvg/rootlv console=ttyS1,9600 crashkernel=128M@16M nousb

  cat /proc/cmdline |grep -q "root=/dev/mapper/$ROOTVG-rootlv_snap \|root=/dev/$ROOTVG/rootlv_snap "

  if [ $? -ne 0 ]

  then

    debug "[ERROR] This option can only be used to rollback when booted from the snapshot (ABE)"

    exit 1

  fi

 

# Im not checking if a snap volume exists for each rootvg volume because the system is booted from the snap

 

# Check the status of the snapshot volumes before rolling back

  debug "[INFO] confirming status of the snapshot volumes"

  for lv in $SNAPLV

  do

        SNAP_USAGE=`/sbin/lvs 2>/dev/null | grep ${lv}_snap | awk '{print $6}' | grep 100`

        if [ ${SNAP_USAGE}x = "x" ]

        then

                # ok, the volume is not full. Check if INACTIVE

                SNAP_STATE=`/sbin/lvdisplay /dev/$ROOTVG/${lv}_snap 2>/dev/null | grep "snapshot status" | grep INACTIVE`

                if [ ${SNAP_STATE}x != "x" ]

                then

                        debug "[CRITICAL] ${lv}_snap is INACTIVE"

                        exit 1

                fi

        else

                debug "[CRITICAL] ${lv}_snap is FULL. A snapshot that has become full is invalidated to merge into its origin"

                exit 1

        fi

  done

 

## Not required in RHEL 6 BUT required in RHEL 7. Snapshot entry in grub.conf is corrected later for RHEL 6 (in RHEL 7 grub.cfg is not corrected later)

  if [ -f /boot/grub2/grub.cfg.snapshot ]

  then

        cp /boot/grub2/grub.cfg.snapshot /boot/grub2/grub.cfg

        if [ $? -eq 0 ]

        then

              debug "[INFO] RHEL 7 Previous /boot/grub2/grub.cfg has been restored"

        fi

  else

        debug "[FAIL] RHEL 7 /boot/grub2/grub.cfg.snapshot file was NOT found to restore the original grub2 configuration"

  fi

 

  for lv in $SNAPLV

  do

        uname -r |grep -q ^2.6.32

        if [ $? -eq 0 ]

        then # this must be rhel6, we can use lvm snapshots.

                debug "[INFO] RHEL 6 rolling back to $lv"

                /sbin/lvconvert --merge /dev/rootvg/${lv}_snap

        else

                uname -r |grep -q ^3.10.0

                if [ $? -eq 0 ] # this must be rhel7, we can rollback lvm snapshots.

                then

                        debug "[INFO] RHEL 7 rolling back to $lv"

                        /sbin/lvconvert --merge /dev/rootvg/${lv}_snap

                else

                        debug "[ERROR] Option only available for RHEL 6 and RHEL 7"

                        exit 1

                fi

        fi

  done

 

  ###### RHEL 6 and 7:

  # The /boot contents will NOT be automatically recovered as part of the rollback function (/boot is a partition, not a LVM volume). In case of a /boot corruption the contents of it can be recovered to the previous status that was collected #before creating the snapshot using the /var/snapshot_boot_backup backup. To do it manually the following can be done:

  # rm -rf /boot/*

  # cp -r /var/snapshot_boot_backup/boot/* /boot

  # rm -r /var/snapshot_boot_backup

  # if required install grub into the drive using grub-install /dev/xxxx

  ######

 

  debug "[INFO] fixing fstab"

  sed -i s/_snap// /etc/fstab

 

  # Remove snapshot entry from grub.conf

uname -r |grep -q ^2.6.32

if [ $? -eq 0 ]

then # this must be rhel6

  debug "[INFO] RHEL 6 removing snapshot entry from grub.conf"

grep -i "^title.*abe\|^title.*snapshot" /boot/grub/grub.conf |sed 's/^title\ //' |while read T

do

echo "T=$T="

/sbin/grubby --remove-kernel=TITLE="$T"

done

  # Ensure grub points to the current booted kernel (RHEL 6)

  grub_boot_current_kernel

### else

#### Nothing to do in RHEL 7, grub.cfg has been restored previously

## uname -r |grep -q ^3.10.0

##  if [ $? -eq 0 ]

##  then # this must be rhel7

##      debug "[INFO] RHEL 7 checking grub2 and deleting snapshot information in it"

##/sbin/grubby --info=ALL|grep -i "^title.*abe\|^title.*snapshot"|awk -F= '{print $2}'|while read T

##do

## echo "T=$T="

## /sbin/grubby --remove-kernel=TITLE="$T"

##done

##  fi

fi

 

 debug "[CRITICAL] Please REBOOT the server immediately to apply the rollback. If running from rundeck the server will be automatically rebooted now"

}

 

function checkrhel {

  grep -q "^Red Hat Enterprise Linux Server release 6" /etc/redhat-release

  if [ $? -ne 0 ]

  then

        grep -q "^Red Hat Enterprise Linux Server release 7" /etc/redhat-release

        if [ $? -ne 0 ]

        then

                debug "[ERROR] Sorry, this only works on RHEL6 or RHEL7"

                exit 1

        fi

  fi

}

 

function prepare_grub {

  sed -i "s/speed=9600/speed=115200/g" /boot/grub/grub.conf

}

 

checkrhel

 

if [ $# -ne 1 ]

then

  usage

fi

 

case $1 in

  "check") checkstuff;;

  "checkfull") checkfull;;

  "PBEsnap") PBEmakesnap;;

  "remove") rmstuff;;

  "removefullsnap") rmfullsnap;;

  "PBErollback") PBErollbacksnap;;

  "snap") makesnap;;

  "rollback") rollbacksnap;;

  * ) usage;;

esac

exit $GLOBALRET
